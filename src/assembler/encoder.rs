use crate::assembler::{AstNode, InstructionNode, ParameterNode};
/// Bytecode encoder for Core War
///
/// This module generates bytecode from an Abstract Syntax Tree (AST)
/// representation of a Redcode program.
use crate::error::{CoreWarError, Result};
use crate::vm::instruction::{CompleteInstruction, Instruction, Parameter, ParameterType};
use std::collections::HashMap;

/// Magic number for Core War executable files
const COR_MAGIC: u32 = 0xea83f3;

/// Encoder for generating Core War bytecode
#[derive(Debug)]
pub struct Encoder {
    /// Symbol table for label resolution
    symbol_table: HashMap<String, usize>,
    /// Current code address
    current_address: usize,
}

impl Encoder {
    /// Create a new encoder
    pub fn new() -> Self {
        Self {
            symbol_table: HashMap::new(),
            current_address: 0,
        }
    }

    /// Encode an AST into bytecode
    ///
    /// # Arguments
    /// * `ast` - The Abstract Syntax Tree to encode
    ///
    /// # Returns
    /// The generated bytecode as a Vec<u8>
    pub fn encode(&mut self, ast: &AstNode) -> Result<Vec<u8>> {
        // First pass: build symbol table
        self.build_symbol_table(&ast.instructions)?;

        // Debug: print symbol table
        println!("[DEBUG] Symbol table: {{");
        for (label, addr) in &self.symbol_table {
            println!("    '{}': {}", label, addr);
        }
        println!("}}");

        // Second pass: generate code
        let code = self.generate_code(&ast.instructions)?;

        // Generate header and combine with code
        let header = self.generate_header(&ast.header.name, &ast.header.comment, code.len())?;

        let mut bytecode = Vec::new();
        bytecode.extend(header);
        bytecode.extend(code);

        Ok(bytecode)
    }

    /// Build the symbol table by scanning for labels
    fn build_symbol_table(&mut self, instructions: &[InstructionNode]) -> Result<()> {
        self.current_address = 0;
        self.symbol_table.clear();

        for instruction in instructions {
            // Add label to symbol table if present
            if let Some(ref label) = instruction.label {
                let normalized_label = label.trim().trim_end_matches(':');
                if self.symbol_table.contains_key(normalized_label) {
                    return Err(CoreWarError::assembler(format!(
                        "Duplicate label '{}' at line {}",
                        normalized_label, instruction.line_number
                    )));
                }
                self.symbol_table
                    .insert(normalized_label.to_string(), self.current_address);
            }

            // Calculate instruction size
            let instruction_enum = self.parse_instruction_mnemonic(&instruction.mnemonic)?;
            let size =
                self.calculate_instruction_size(&instruction_enum, &instruction.parameters)?;
            self.current_address += size;
        }

        Ok(())
    }

    /// Generate the actual bytecode
    fn generate_code(&mut self, instructions: &[InstructionNode]) -> Result<Vec<u8>> {
        let mut code = Vec::new();
        self.current_address = 0;

        for instruction in instructions {
            let bytecode = self.encode_instruction(instruction)?;
            code.extend(bytecode);
        }

        Ok(code)
    }

    /// Encode a single instruction
    fn encode_instruction(&mut self, instruction_node: &InstructionNode) -> Result<Vec<u8>> {
        let instruction = self.parse_instruction_mnemonic(&instruction_node.mnemonic)?;
        let parameters = self.parse_parameters(&instruction_node.parameters)?;

        let complete_instruction = CompleteInstruction::new(instruction, parameters)?;
        let start_address = self.current_address;

        // Update current address for next instruction
        self.current_address += complete_instruction.size();

        // Encode the instruction
        let mut bytecode = Vec::new();

        // Encode opcode
        bytecode.push(complete_instruction.instruction.opcode());

        // Encode parameter types (2 bits per parameter, packed into bytes)
        let param_types_byte = self.encode_parameter_types(&complete_instruction.parameters);
        bytecode.push(param_types_byte);

        // Encode parameters
        for (i, parameter) in complete_instruction.parameters.iter().enumerate() {
            let param_bytes = self.encode_parameter(
                parameter,
                start_address
                    + 2
                    + complete_instruction.parameters[..i]
                        .iter()
                        .map(|p| p.param_type.size())
                        .sum::<usize>(),
            )?;
            bytecode.extend(param_bytes);
        }

        Ok(bytecode)
    }

    /// Parse instruction mnemonic into Instruction enum
    fn parse_instruction_mnemonic(&self, mnemonic: &str) -> Result<Instruction> {
        match mnemonic.to_lowercase().as_str() {
            "live" => Ok(Instruction::Live),
            "ld" => Ok(Instruction::Ld),
            "st" => Ok(Instruction::St),
            "add" => Ok(Instruction::Add),
            "sub" => Ok(Instruction::Sub),
            "and" => Ok(Instruction::And),
            "or" => Ok(Instruction::Or),
            "xor" => Ok(Instruction::Xor),
            "zjmp" => Ok(Instruction::Zjmp),
            "ldi" => Ok(Instruction::Ldi),
            "sti" => Ok(Instruction::Sti),
            "fork" => Ok(Instruction::Fork),
            "lld" => Ok(Instruction::Lld),
            "lldi" => Ok(Instruction::Lldi),
            "lfork" => Ok(Instruction::Lfork),
            "aff" => Ok(Instruction::Aff),
            _ => Err(CoreWarError::assembler(format!(
                "Unknown instruction: {}",
                mnemonic
            ))),
        }
    }

    /// Parse parameter nodes into Parameter structs
    fn parse_parameters(&self, param_nodes: &[ParameterNode]) -> Result<Vec<Parameter>> {
        let mut parameters = Vec::new();

        for param_node in param_nodes {
            let parameter = match param_node.param_type.as_str() {
                "register" => {
                    let reg_num: u8 =
                        param_node
                            .value
                            .trim_start_matches('r')
                            .parse()
                            .map_err(|_| {
                                CoreWarError::assembler(format!(
                                    "Invalid register: {}",
                                    param_node.value
                                ))
                            })?;

                    if reg_num == 0 || reg_num > 16 {
                        return Err(CoreWarError::assembler(format!(
                            "Register out of range: r{}",
                            reg_num
                        )));
                    }

                    Parameter::register(reg_num)
                }
                "direct" => {
                    let value: i32 = param_node.value.parse().map_err(|_| {
                        CoreWarError::assembler(format!(
                            "Invalid direct value: {}",
                            param_node.value
                        ))
                    })?;
                    Parameter::direct(value)
                }
                "indirect" => {
                    let value: i32 = param_node.value.parse().map_err(|_| {
                        CoreWarError::assembler(format!(
                            "Invalid indirect value: {}",
                            param_node.value
                        ))
                    })?;
                    Parameter::indirect(value)
                }
                "label" => {
                    let normalized_label = param_node.value.trim().trim_end_matches(':');
                    let label_address =
                        self.symbol_table.get(normalized_label).ok_or_else(|| {
                            CoreWarError::assembler(format!(
                                "Undefined label: {}",
                                normalized_label
                            ))
                        })?;
                    Parameter::label(*label_address as i32)
                }
                _ => {
                    return Err(CoreWarError::assembler(format!(
                        "Unknown parameter type: {}",
                        param_node.param_type
                    )));
                }
            };

            parameters.push(parameter);
        }

        Ok(parameters)
    }

    /// Calculate the size of an instruction in bytes
    fn calculate_instruction_size(
        &self,
        instruction: &Instruction,
        parameters: &[ParameterNode],
    ) -> Result<usize> {
        if parameters.len() != instruction.parameter_count() {
            return Err(CoreWarError::assembler(format!(
                "Invalid parameter count for {}: expected {}, got {}",
                instruction.name(),
                instruction.parameter_count(),
                parameters.len()
            )));
        }

        let mut size = 2; // opcode + parameter types byte

        for param in parameters {
            size += match param.param_type.as_str() {
                "register" => 1,
                "direct" | "indirect" | "label" => 2,
                _ => {
                    return Err(CoreWarError::assembler(format!(
                        "Unknown parameter type: {}",
                        param.param_type
                    )));
                }
            };
        }

        Ok(size)
    }

    /// Encode parameter types into a single byte
    fn encode_parameter_types(&self, parameters: &[Parameter]) -> u8 {
        let mut types_byte = 0u8;

        for (i, param) in parameters.iter().enumerate() {
            if i >= 4 {
                break; // Maximum 4 parameters, 2 bits each
            }

            let type_code = param.param_type.type_code();
            types_byte |= type_code << (6 - i * 2);
        }

        types_byte
    }

    /// Encode a single parameter
    fn encode_parameter(&self, parameter: &Parameter, _current_pc: usize) -> Result<Vec<u8>> {
        match parameter.param_type {
            ParameterType::Register => Ok(vec![parameter.value as u8]),
            ParameterType::Direct | ParameterType::Indirect | ParameterType::Label => {
                // Encode as 16-bit little-endian
                let value = parameter.value as u16;
                Ok(vec![(value & 0xFF) as u8, ((value >> 8) & 0xFF) as u8])
            }
        }
    }

    /// Generate the champion header
    fn generate_header(&self, name: &str, comment: &str, code_size: usize) -> Result<Vec<u8>> {
        let mut header = Vec::new();

        // Magic number (4 bytes, little-endian)
        let magic_bytes = COR_MAGIC.to_le_bytes();
        header.extend(&magic_bytes);

        // Program name (128 bytes, null-terminated)
        let mut name_bytes = [0u8; 128];
        let name_bytes_src = name.as_bytes();
        if name_bytes_src.len() >= 128 {
            return Err(CoreWarError::assembler(
                "Program name too long (max 127 characters)".to_string(),
            ));
        }
        name_bytes[..name_bytes_src.len()].copy_from_slice(name_bytes_src);
        header.extend(&name_bytes);

        // Padding (4 bytes)
        header.extend(&[0u8; 4]);

        // Code size (4 bytes, little-endian)
        let size_bytes = (code_size as u32).to_le_bytes();
        header.extend(&size_bytes);

        // Comment (128 bytes, null-terminated)
        let mut comment_bytes = [0u8; 128];
        let comment_bytes_src = comment.as_bytes();
        if comment_bytes_src.len() >= 128 {
            return Err(CoreWarError::assembler(
                "Comment too long (max 127 characters)".to_string(),
            ));
        }
        comment_bytes[..comment_bytes_src.len()].copy_from_slice(comment_bytes_src);
        header.extend(&comment_bytes);

        // Padding (4 bytes)
        header.extend(&[0u8; 4]);

        Ok(header)
    }
}

impl Default for Encoder {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_symbol_table_building() {
        let mut encoder = Encoder::new();
        let instructions = vec![
            InstructionNode {
                label: Some("start".to_string()),
                mnemonic: "live".to_string(),
                parameters: vec![ParameterNode {
                    param_type: "direct".to_string(),
                    value: "1".to_string(),
                }],
                line_number: 1,
            },
            InstructionNode {
                label: Some("loop".to_string()),
                mnemonic: "zjmp".to_string(),
                parameters: vec![ParameterNode {
                    param_type: "label".to_string(),
                    value: "start".to_string(),
                }],
                line_number: 2,
            },
        ];

        encoder.build_symbol_table(&instructions).unwrap();

        assert_eq!(encoder.symbol_table.get("start"), Some(&0));
        assert!(encoder.symbol_table.get("loop").is_some());
    }

    #[test]
    fn test_instruction_parsing() {
        let encoder = Encoder::new();
        assert_eq!(
            encoder.parse_instruction_mnemonic("live").unwrap(),
            Instruction::Live
        );
        assert_eq!(
            encoder.parse_instruction_mnemonic("LIVE").unwrap(),
            Instruction::Live
        );
        assert!(encoder.parse_instruction_mnemonic("invalid").is_err());
    }

    #[test]
    fn test_header_generation() {
        let encoder = Encoder::new();
        let header = encoder
            .generate_header("test", "A test program", 10)
            .unwrap();

        // Check magic number (first 4 bytes)
        let magic = u32::from_le_bytes([header[0], header[1], header[2], header[3]]);
        assert_eq!(magic, COR_MAGIC);

        // Check that header has correct total size
        assert_eq!(header.len(), 4 + 128 + 4 + 4 + 128 + 4); // magic + name + pad + size + comment + pad
    }
}
